/**
 * Created on 1401/12/18 (2023/3/9).
 * @author {@link https://mirismaili.github.io S. Mahdi Mir-Ismaili}
 */

import {transpose} from './array-utils.js'

function parseWindowsGitDiff (diffCommandOutput) {
  const rawDiffs = diffCommandOutput.replaceAll(/\x1b\[(91|92|39)m/g, '')

  const sections = rawDiffs.split('\n\n').slice(0, -1)

  const LINE_NUMBER_REGEX = /^ *(\d+|\.+)(?= )/

  return sections.map((section) => {
    const splitContent = section.split('\n', 1)
    const firstLine = splitContent[0]
    const [filePath, ...rest] = firstLine.split(' --- ')
    const [partNumberOfAll, fileType] = rest.length === 2 ? rest : ['1/1', rest[0]]

    const rawDiff = section.slice(firstLine.length + 1)

    if (rawDiff === 'No syntactic changes.' || rawDiff === 'No changes.')
      return {filePath, partNumberOfAll, fileType, diff: []}

    const rawDiffLines = rawDiff.split('\n')
    const is2ColumnFormat = detectTwoColumnFormat(rawDiffLines)

    const firstDiffLine = rawDiffLines[0] // Just choose a line
    const numDigitsOfLineNumbers0 = firstDiffLine.match(LINE_NUMBER_REGEX)[0].length
    const numDigitsOfLineNumbers1 = is2ColumnFormat
      ? firstDiffLine.slice(40).match(LINE_NUMBER_REGEX)[0].length
      : firstDiffLine.slice(numDigitsOfLineNumbers0 + 1).match(LINE_NUMBER_REGEX)[0].length

    const [wrappedSuperLines0, wrappedSuperLines1] = transpose( // A `superLine` is `[lineNumber, lineContent]`
      is2ColumnFormat
        ? rawDiffLines.map((diffLine) => {
          let offset
          return [
            [
              +diffLine.slice(offset = 0, offset += numDigitsOfLineNumbers0) || 0, // line-number (or zero if `NaN`)
              diffLine.slice(offset + 1, offset = 39), // line content
            ],
            [
              +diffLine.slice(offset += 1, offset += numDigitsOfLineNumbers1) || 0, // line-number (or zero if
                                                                                    // `NaN`)
              diffLine.slice(offset + 1), // line content
            ],
          ]
        })
        : rawDiffLines.map((diffLine) => {
          let offset
          const lineNumber0 = +diffLine.slice(offset = 0, offset += numDigitsOfLineNumbers0) || 0 // (zero if `NaN`)
          const expectedLineNumber1 = diffLine.slice(offset += 1, offset += numDigitsOfLineNumbers1)
          const lineNumber1 = +expectedLineNumber1 || 0
          const lineContent = diffLine.slice(LINE_NUMBER_REGEX.test(expectedLineNumber1)
            ? offset + 1
            : offset - numDigitsOfLineNumbers1,
          )
          return [
            [lineNumber0, lineNumber0 ? lineContent : ''],
            [lineNumber1, lineNumber1 ? lineContent : ''],
          ]
        }),
    )

    // const [wrappedNumberedLines0, wrappedNumberedLines1] = transpose(wrappedNumberedDiffLines)
    // 
    // const [numDigitsOfLineNumbers0, numDigitsOfLineNumbers1] = [wrappedNumberedLines0, wrappedNumberedLines1].map(
    //   (content) => content.findLast(// Find the largest line-number
    //     (line) => /^\d+/.test(line),
    //   ).match(/^\d+/)[0].length,
    // )
    // 
    // const [wrappedSuperLines0, wrappedSuperLines1] = [ // `superLine` is `[lineNumber, line]`
    //   [wrappedNumberedLines0, numDigitsOfLineNumbers0],
    //   [wrappedNumberedLines1, numDigitsOfLineNumbers1],
    // ].map(([wrappedLineWithNumber, numDigits]) =>
    //   wrappedLineWithNumber.map((line) => [
    //     +line.slice(0, numDigits) || 0, // line-number (or zero if "." or ".." or ...)
    //     line.slice(numDigits + 1),
    //   ]),
    // )

    const [superLines0, superLines1] = is2ColumnFormat
      ? [wrappedSuperLines0, wrappedSuperLines1].map((wrappedSuperLines) => {
        const superLines = []
        let lastContentfulLineIdx = -1
        for (const [i, wrappedSuperLine] of wrappedSuperLines.entries()) {
          const lastContentfulSuperLine = superLines[lastContentfulLineIdx]
          if (wrappedSuperLine[0]) {
            superLines.push([...wrappedSuperLine])
            lastContentfulLineIdx = i
          } else {
            superLines.push([0, ''])
            lastContentfulSuperLine[1] += wrappedSuperLine[1]
          }
        }
        return superLines
      })
      : [wrappedSuperLines0, wrappedSuperLines1]

    superLines0.forEach((superLine) => (superLine[1] = superLine[1].trimEnd()))

    const parsedDiff = transpose([superLines0, superLines1]).filter(
      ([[n0, l0], [n1, l1]]) => (!n0 ^ !n1) || (n0 && n1 && l0 !== l1),
    )

    // const parsedDiffStr = parsedDiff.map(([[n0, l0], [n1, l1]]) =>
    //     `${n0 ? `${n0}.${JSON.stringify(l0)}` : 'X'} >>> ${n1 ? `${n1}.${JSON.stringify(l1)}` : 'X'}`
    // ).join('\n')

    return {filePath, partNumberOfAll, fileType, diff: parsedDiff}
  })
}

/**
 * @param {string[]} rawDiffLines
 * @returns {boolean}
 */
function detectTwoColumnFormat (rawDiffLines) {
  let is2Column = true
  let i = 0
  for (; i < rawDiffLines.length; i++) {
    const diffLine = rawDiffLines[i]
    if (diffLine[39] !== ' ') {
      is2Column = false
      break
    }
    if (diffLine.length <= 80 && LINE_NUMBER_REGEX.test(diffLine.slice(40))) continue
    break // Go to the next `for` loop (in the below `if` block) to check remaining lines...
  }
  if (is2Column === true && i < rawDiffLines.length) {
    // const boundary = i
    for (; i < rawDiffLines.length; i++) {
      const diffLine = rawDiffLines[i]
      if (diffLine[39] !== ' ' || diffLine.length > 40) {
        is2Column = false
        break
      }
    }
    // const numDigitsOfLineNumbers1 = rawDiffLines[boundary - 1].slice(40).match(LINE_NUMBER_REGEX)[0].length
    // if (is2Column)
    //   for (i = boundary; i < rawDiffLines.length; i++)
    //     rawDiffLines[i] += `${'.'.repeat(numDigitsOfLineNumbers1)} ` // Fix line number consistency of the second
    // column
  }
  return is2Column
}
